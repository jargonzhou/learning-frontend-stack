{
  // Specifies an allowlist of files to include in the program. An error occurs if any of the files can’t be found.
  // Default: false
  "files": [],
  // The value of extends is a string which contains a path to another configuration file to inherit from. The path may use Node.js style resolution.
  // The configuration from the base file are loaded first, then overridden by those in the inheriting config file. All relative paths found in the configuration file will be resolved relative to the configuration file they originated in.
  // Default: false
  "extends": "",
  // Specifies an array of filenames or patterns to include in the program. These filenames are resolved relative to the directory containing the `tsconfig.json` file.
  // Default: `[]` if files is specified; `**/*` otherwise.
  "include": [],
  // Specifies an array of filenames or patterns that should be skipped when resolving `include`.
  // Default: node_modules bower_components jspm_packages `outDir`
  "exclude": [],
  // Project references are a way to structure your TypeScript programs into smaller pieces. Using Project References can greatly improve build and editor interaction times, enforce logical separation between components, and organize your code in new and improved ways.
  // https://www.typescriptlang.org/docs/handbook/project-references.html
  // Default: false
  "references": [],
  "compilerOptions": {
    //
    // Type Checking
    //
    "allowUnreachableCode": null,
    "allowUnusedLabels": null,
    // Ensures that your files are parsed in the ECMAScript strict mode, and emit “use strict” for each source file.
    // Default: true if `strict`; false otherwise.
    "alwaysStrict": null,
    "exactOptionalPropertyTypes": null,
    "noFallthroughCasesInSwitch": null,
    "noImplicitAny": null, // strict mode
    "noImplicitOverride": null,
    "noImplicitReturns": null,
    "noImplicitThis": null,
    "noPropertyAccessFromIndexSignature": null,
    "noUncheckedIndexedAccess": null,
    "noUnusedLocals": null,
    "noUnusedParameters": null,
    // The `strict` flag enables a wide range of type checking behavior that results in stronger guarantees of program correctness. Turning this on is equivalent to enabling all of the 'strict mode family' options, which are outlined below. You can then turn off individual strict mode family checks as needed.
    "strict": null,
    "strictBindCallApply": null, // strict mode
    "strictBuiltinIteratorReturn": null,
    "strictFunctionTypes": null, // strict mode
    // When `strictNullChecks` is `false`, `null` and `undefined` are effectively ignored by the language. This can lead to unexpected errors at runtime. When `strictNullChecks` is `true`, `null` and `undefined` have their own distinct types and you’ll get a type error if you try to use them where a concrete value is expected.
    // Default: true if `strict`; false otherwise.
    "strictNullChecks": null, // strict mode
    "strictPropertyInitialization": null, // strict mode
    "useUnknownInCatchVariables": null, // strict mode
    //
    // Modules
    //
    "allowArbitraryExtensions": null,
    "allowImportingTsExtensions": null,
    "allowUmdGlobalAccess": null,
    "baseUrl": null,
    "customConditions": null,
    // Sets the module system for the program./目标使用的模块系统
    // Default:
    //  CommonJS if `target` is ES5;
    //  ES6/ES2015 otherwise.
    // Allowed: none commonjs amd umd system es6/es2015 es2020 es2022 esnext node16 node18 node20 nodenext preserves
    "module": null,
    // Specify the module resolution strategy/模块解析策略
    // Default:
    //  Node10 if module is CommonJS;
    //  Node16 if module is Node16, Node18, or Node20;
    //  NodeNext if module is NodeNext;
    //  Bundler if module is Preserve;
    //  Classic otherwise.
    // Allowed: classic node10/node node16 nodenext bundler
    "moduleResolution": null,
    // Provides a way to override the default list of file name suffixes to search when resolving a module.
    "moduleSuffixes": [],
    "noResolve": null,
    "noUncheckedSideEffectImports": null,
    "paths": null,
    // Allows importing modules with a `.json` extension, which is a common practice in node projects. This includes generating a type for the `import` based on the static JSON shape.
    "resolveJsonModule": null,
    "resolvePackageJsonExports": null,
    "resolvePackageJsonImports": null,
    "rewriteRelativeImportExtensions": null,
    // Default: The longest common path of all non-declaration input files. If `composite` is set, the default is instead the directory containing the `tsconfig.json` file.
    "rootDir": null,
    // Using `rootDirs`, you can inform the compiler that there are many “virtual” directories acting as a single root. This allows the compiler to resolve relative module imports within these “virtual” directories, as if they were merged in to one directory.
    "rootDirs": null,
    // By default all visible ”@types” packages are included in your compilation. Packages in `node_modules/@types` of any enclosing folder are considered visible. 
    // If `typeRoots` is specified, only packages under `typeRoots` will be included.
    "typeRoots": null,
    // If `types` is specified, only packages listed will be included in the global scope. 
    "types": null,
    //
    // Emit
    //
    // Generate `.d.ts` files for every TypeScript or JavaScript file inside your project. These `.d.ts` files are type definition files which describe the external API of your module. With `.d.ts` files, tools like TypeScript can provide intellisense and accurate types for un-typed code.
    // Default: true if `composite`; false otherwise.
    "declaration": false,
    // Offers a way to configure the root directory for where declaration files are emitted.
    "declarationDir": "",
    // Generates a source map(`.d.ts.map`) for `.d.ts` files which map back to the original `.ts` source file. This will allow editors such as VS Code to go to the original `.ts` file when using features like 'Go to Definition'.
    "declarationMap": false,
    "downlevelIteration": null,
    "emitBOM": null,
    // Only emit `.d.ts` files; do not emit `.js` files.
    "emitDeclarationOnly": false,
    "importHelpers": null,
    "inlineSourceMap": null,
    "inlineSources": null,
    "mapRoot": null,
    "newLine": null,
    // Do not emit compiler output files like JavaScript source code, source-maps or declarations.
    "noEmit": false,
    "noEmitHelpers": null,
    "noEmitOnError": null,
    "outDir": null,
    "outFile": null,
    "preserveConstEnums": null,
    "removeComments": null,
    // Enables the generation of sourcemap files. These files allow debuggers and other tools to display the original TypeScript source code when actually working with the emitted JavaScript files. Source map files are emitted as `.js.map` (or `.jsx.map`) files next to the corresponding .js output file.
    "sourceMap": false,
    "sourceRoot": null,
    "stripInternal": null,
    //
    // JavaScript Support
    //
    // Allow JavaScript files to be imported inside your project, instead of just `.ts` and `.tsx` files.
    "allowJs": false,
    // Works in tandem with `allowJs`. When `checkJs` is enabled then errors are reported in JavaScript files. This is the equivalent of including `// @ts-check` at the top of all JavaScript files which are included in your project.
    "checkJs": false,
    "maxNodeModuleJsDepth": null,
    //
    // Editor Support
    //
    "disableSizeLimit": null,
    "plugins": null,
    //
    // Interop Constraints
    //
    "allowSyntheticDefaultImports": null,
    "erasableSyntaxOnly": null,
    // By default (with `esModuleInterop` false or not set) TypeScript treats CommonJS/AMD/UMD modules similar to ES6 modules.
    "esModuleInterop": null,
    "forceConsistentCasingInFileNames": null,
    "isolatedDeclarations": null,
    "isolatedModules": null,
    "preserveSymlinks": null,
    "verbatimModuleSyntax": null,
    //
    // Backwards Compatibility
    //
    "charset": null,
    "importsNotUsedAsValues": null,
    "keyofStringsOnly": null,
    "noImplicitUseStrict": null,
    "noStrictGenericChecks": null,
    "out": null,
    "preserveValueImports": null,
    "suppressExcessPropertyErrors": null,
    "suppressImplicitAnyIndexErrors": null,
    //
    // Language and Environment
    //
    "emitDecoratorMetadata": null,
    // Enables experimental support for decorators, which is a version of decorators that predates the TC39 standardization process.
    "experimentalDecorators": false,
    // Controls how JSX constructs are emitted in JavaScript files. This only affects output of JS files that started in .tsx files.
    // Allowed: preserve react react-native react-jsx react-jsxdev
    "jsx": "preserve",
    "jsxFactory": null,
    "jsxFragmentFactory": null,
    "jsxImportSource": null,
    // TypeScript includes a default set of type definitions for built-in JS APIs (like Math), as well as type definitions for things found in browser environments (like document). TypeScript also includes APIs for newer JS features matching the target you specify; for example the definition for Map is available if target is ES6 or newer. In TypeScript 4.5, lib files can be overridden by npm modules.
    // https://github.com/microsoft/TypeScript/tree/main/src/lib
    "lib": null,
    // TypeScript 4.5 introduced the possibility of substituting the default lib files with custom ones. All built-in library files would first try to be resolved from packages named `@typescript/lib-*`.
    // ex: lock your dom libraries onto a specific version of the @types/web package
    // {
    //   "devDependencies": {
    //     "@typescript/lib-dom": "npm:@types/web@0.0.199"
    //   }
    // }
    "libReplacement": null,
    // This setting controls how TypeScript determines whether a file is a script or a module.
    // Default: "auto": Treat files with imports, exports, import.meta, jsx (with jsx: react-jsx), or esm format (with module: node16+) as modules.
    // Allowed: legacy auto force
    "moduleDetection": "auto",
    "noLib": null,
    "reactNamespace": null,
    // The target setting changes which JS features are downleveled and which are left intact.
    // Default: es2023 if module is node20; esnext if module is nodenext; ES5 otherwise.
    // Allowed: es3 es5 es6/es2015 es2016 es2017 es2018 es2019 es2020 es2021 es2022 es2023 es2024 esnext
    "target": "es5",
    "useDefineForClassFields": null,
    //
    // Compiler Diagnostics
    //
    "diagnostics": null,
    "explainFiles": null,
    "extendedDiagnostics": null,
    "generateCpuProfile": null,
    "generateTrace": null,
    "listEmittedFiles": null,
    "listFiles": null,
    "noCheck": null,
    "traceResolution": null,
    //
    // Projects
    // 
    // The composite option enforces certain constraints which make it possible for build tools (including TypeScript itself, under --build mode) to quickly determine if a project has been built yet.
    "composite": false,
    "disableReferencedProjectLoad": null,
    "disableSolutionSearching": null,
    "disableSourceOfProjectReferenceRedirect": null,
    "incremental": null,
    "tsBuildInfoFile": null,
    //
    // Output Formatting
    //
    "noErrorTruncation": null,
    "preserveWatchOutput": null,
    "pretty": null,
    //
    // Completeness
    //
    // Use `skipLibCheck` instead. Skip type checking of default library declaration files.
    "skipDefaultLibCheck": null,
    // Skip type checking of declaration files.
    "skipLibCheck": false,
    //
    // Command Line
    //
    //
    // Watch Options
    //
    "assumeChangesOnlyAffectDirectDependencies": null
  },
  "watchOptions": {
    "watchFile": null,
    "watchDirectory": null,
    "fallbackPolling": null,
    "synchronousWatchDirectory": null,
    "excludeDirectories": null,
    "excludeFiles": null,
  },
  "typeAcquisition": {
    "enable": null,
    "include": null,
    "exclude": null,
    "disableFilenameBasedTypeAcquisition": null
  }
}